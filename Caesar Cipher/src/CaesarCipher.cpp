#include <cstdlib>
#include <ctime>
#include "Cipher.h"


CaesarCipher::CaesarCipher(const std::string& input_file, const std::string& output_file) {
	this->input_file = input_file;

	if (output_file == "") {
		// Search for '.' in the input_file variable. Anything after the '.' will give us
		// the file extension
		size_t location = input_file.find_last_of(".");

		// If '.' is not found, that means the file does not have any extension.
		// In that case, we will just append "_encrypted" to the original file
		if (location == std::string::npos) {
			this->encrypted_file = input_file + "_encrypted";
			this->decrypted_file = input_file + "_decrypted";
		}

		// If an extension is present, we will still append "_encrypted" to the file
		// but this will be appended before the extension (obviously!)
		else {
			this->encrypted_file = input_file.substr(0, location) + "_encrypted" + input_file.substr(location);
			this->decrypted_file = input_file.substr(0, location) + "_decrypted" + input_file.substr(location);
		}
	}
	else {
		this->encrypted_file = output_file;
		this->decrypted_file = output_file;
	}
}


std::string CaesarCipher::keyGenerator() {
	// The remainder helps to keep track of the total sum of ASCII characters of the
	// key. The total sum cannot be 95 because we have a total of 95 printable characters
	// which we are considering here and if the total sum becomes some multiple of 95,
	// The remainder becomes 0 (because we are doing sum % 95) and the plain text and
	// encrypted text becomes the same!
	int remainder = 0;

	while (remainder == 0) {
		// Seeds the random number generator
		std::srand((unsigned)time(0));
		int sum = 0;

		// The total length of the key is determined by the instance variable 'key_length'
		for (int count = 1; count <= key_length; count++) {
			// We will have capital letters in odd positions
			if (count % 2 == 1) {
				int tempInt = (std::rand() % 26) + 65;
				sum += tempInt;
				KEY += char(tempInt);
			}
			// And numbers in even positions
			else {
				int tempInt = (std::rand() % 10) + 48;
				sum += tempInt;
				KEY += char(tempInt);
			}
		}

		remainder = sum % 95;
	}

	return KEY;
}


void CaesarCipher::encrypt(const std::string& key) {
	// If both the input key and the class variable KEY are empty, then throw error
	if (key == "" && KEY == "")
		throw "Invalid Key";
	// If a key has been provided to this function, then assign the key to the class
	// variable KEY
	else if (key != "")
		KEY = key;

	// Calculate the shift for shifting the characters.
	// In total, we are dealing with 95 printable characters here. So we find the MOD of 95
	// as it would give us a value between 1 and 94. We should not get 0 as it would not 
	// change the plain text. If the key generated by the keyGenerator function is used,
	// then this condition will not arise. But if custom keys are being used, then this
	// can happen. In that case, we will throw an error.
	int shift = 0;
	for (int index = 0; index < KEY.length(); index++)
		shift += int(KEY.at(index));
	shift = shift % 95;
	if (shift == 0)
		throw "Invalid Key";

	// Open the input and output files
	std::ifstream plaintext_file(input_file);
	if (!plaintext_file)
		throw "Plain-Text file cannot be opened";
	std::ofstream output_file(encrypted_file);
	if (!output_file) {
		plaintext_file.close();
		throw "Output file cannot be generated";
	}

	// Extract each character from the input file, shift it required number of places
	// and write it to the output file. Apply the shift only to the printable characters
	// which lie in the range ASCII = 32 to ASCII = 126
	char ch;
	while (plaintext_file.get(ch)) {
		if (ch >= 32 && ch <= 126) {
			ch = char((ch - 32 + shift) % 95) + 32;
			output_file << ch;
		}
		else
			output_file << ch;
	}

	// Close the files
	plaintext_file.close();
	output_file.close();
}


void CaesarCipher::decrypt(const std::string& key) {
	// If.the input key is empty, then throw error
	if (key == "")
		throw "Invalid Key";

	// Calculate the shift for shifting the characters.
	// The process is the same as that in encryption
	int shift = 0;
	for (int index = 0; index < key.length(); index++)
		shift += int(key.at(index));
	shift = shift % 95;
	if (shift == 0)
		throw "Invalid Key";

	// Open the input and output files
	std::ifstream encrypted_input_file(input_file);
	if (!encrypted_input_file)
		throw "Encrypted file cannot be opened";
	std::ofstream output_file(decrypted_file);
	if (!output_file) {
		encrypted_input_file.close();
		throw "Output file cannot be generated";
	}

	// Extract each character from the input file, shift it required number of places
	// and write it to the output file. Apply the shift only to the printable characters
	// which lie in the range ASCII = 32 to ASCII = 126
	char ch;
	while (encrypted_input_file.get(ch)) {
		if (ch >= 32 && ch <= 126) {
			// We need to add the 95 because for some reason, we cannot find out
			// modulus of a negative number correctly here!
			ch = char((ch - 32 - shift + 95) % 95) + 32;
			output_file << ch;
		}
		else
			output_file << ch;
	}

	// Close the files
	encrypted_input_file.close();
	output_file.close();
}